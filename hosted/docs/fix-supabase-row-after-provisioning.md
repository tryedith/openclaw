# Fix: Create Supabase instance row only after successful EC2 provisioning

## Problem

When "Create Bot" fails (e.g. Secrets Manager error, EC2 launch failure, AWS credential issue), a Supabase row is still created with `status: "error"`. This is confusing — the user sees a broken instance they didn't ask for, and the "1 instance per user" limit blocks retrying.

## Current flow (`hosted/apps/web/src/app/api/instances/route.ts` POST handler)

```
1. Auth check
2. Instance limit check (max 1 per user)
3. INSERT Supabase row (status: "provisioning", gateway_token_encrypted: "pending")  ← row created
4. Try EC2 provisioning (instanceClient.createInstance)
5. Success → UPDATE row with real data (status: "running", token, URLs)
6. Failure → UPDATE row to status: "error"  ← stale row persists, blocks retry
```

## Desired flow

```
1. Auth check
2. Instance limit check (max 1 per user)
3. Try EC2 provisioning (instanceClient.createInstance)
4. Failure → return error response, NO Supabase row created, user can retry
5. Success → INSERT Supabase row with all real data in one shot:
   - status: "running"
   - gateway_token_encrypted: encryptGatewayToken(gatewayToken)
   - provider_resource_id, aws_service_arn, aws_target_group_arn, aws_rule_arn, public_url
6. If Supabase insert fails → return error (EC2 exists but no row; pool cleanup handles orphans)
```

## Change: `hosted/apps/web/src/app/api/instances/route.ts`

Replace lines 117-194 (the insert-then-update pattern) with provision-then-insert:

```typescript
// POST /api/instances - Create a new instance
export async function POST() {
  const supabase = await createClient();
  const { data: { user } } = await supabase.auth.getUser();

  if (!user) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  // Check instance limit
  const { count } = await supabase
    .from("instances")
    .select("*", { count: "exact", head: true })
    .eq("user_id", user.id);

  if (count && count >= 1) {
    return NextResponse.json(
      { error: "Instance limit reached. Free tier allows 1 instance." },
      { status: 400 }
    );
  }

  // Provision EC2 first — no Supabase row until this succeeds
  let provisionResult;
  try {
    const instanceClient = getInstanceClient();
    // Generate a temporary ID for the instance (needed by createInstance for subdomain)
    const instanceId = crypto.randomUUID();
    provisionResult = await instanceClient.createInstance({
      userId: user.id,
      instanceId,
    });
  } catch (error) {
    const rawMsg = error instanceof Error ? error.message : "Unknown error";
    const errorMsg =
      rawMsg === "Could not load credentials from any providers"
        ? "Could not load AWS credentials. Set AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY."
        : rawMsg;
    // No Supabase row created — user can retry
    return NextResponse.json(
      { error: "Failed to provision instance: " + errorMsg },
      { status: 500 }
    );
  }

  // EC2 is running — now create the Supabase row with all real data
  const { data: instance, error: insertError } = await supabase
    .from("instances")
    .insert({
      user_id: user.id,
      name: "default",
      status: "running",
      provider: "aws",
      provider_resource_id: provisionResult.ec2InstanceId,
      aws_service_arn: provisionResult.ec2InstanceId,
      aws_target_group_arn: provisionResult.targetGroupArn,
      aws_rule_arn: provisionResult.ruleArn,
      public_url: provisionResult.url,
      gateway_token_encrypted: encryptGatewayToken(provisionResult.gatewayToken),
    })
    .select()
    .single();

  if (insertError) {
    return NextResponse.json(
      { error: "Instance provisioned but failed to save: " + insertError.message },
      { status: 500 }
    );
  }

  return NextResponse.json({
    id: instance.id,
    status: "running",
    url: provisionResult.url,
    message: "Instance is ready.",
  });
}
```

**Note:** The instance ID is currently generated by Supabase on insert. Since we need it before insert (for `createInstance` subdomain routing), we generate it with `crypto.randomUUID()` and pass it to the insert. Verify that the `instances` table allows client-provided UUIDs (i.e., `id` column has a default but accepts explicit values).

## Verification

1. Click "Create Bot" when EC2 provisioning will fail → no row in Supabase, user can retry
2. Click "Create Bot" when provisioning succeeds → row created with `status: "running"`, chat works
3. Instance limit still enforced (can't create 2nd instance)
